```{r include = FALSE}
source("common.R")
set.seed(12L)
columns(1, 1 / 1.61, 1)
```

# Case Study: Springs {#spring1}

## Part 1: A stat

In this chapter we will create our very first extension: A version of `geom_segment()` that instead of drawing a straight line between two points will draw it as a stretched spring.
By the end of it you will hopefully have gained a lot of insight into the process of designing a `Stat` extension along with its benefits and problems.
We will revisit this extension multiple times throughout this chapter.

### Thinking a bit before we code

Usually an extension starts with an idea about what we want to be able to draw.
In this case this is given as the ability to draw a spring between two points, but even with such a clear objective there are plenty of unanswered questions about the interface, e.g. how should the interface look like.
Many of the answers to these questions will be informed by iterations on the implementation, but it is a good idea to think a bit about which capabilities should be present in the layer.
How is the diameter of the spring set?
Is it supposed to be an aesthetic that can be scaled?
What about the spring tension?
Is that a scaled aesthetic as well?
Or are both simple values set for all springs in the layer?

Another thing we need to need to start to think about is how one even draws a spring?
I guess there are many ways, but I would naively think that we trace a circle while also moving the "pen" in one direction:

```{r}
circle <- tibble(
  x = sin(seq(0, 2*pi, length.out = 100)),
  y = cos(seq(0, 2*pi, length.out = 100)),
  index = 1:100,
  type = "circle"
)
spring <- circle
spring$x <- spring$x + seq(0, 1.5, length.out = 100)
spring$type <- "spring"
ggplot(rbind(circle, spring)) + 
  geom_path(aes(x = x, y = y, group = type, alpha = index), show.legend = FALSE) + 
  facet_wrap(~ type, scales = "free_x")
```

It is clear that simply continuing to trace the circle while moving along x will make the spring longer, and that the speed of the x-movement will control the tension of the spring.
While I'm pretty sure this is not a physically correct parameterisation of a spring, it is good enough for our illustrative purpose.

### Choosing an approach

When developing a new layer, one has a choice between developing a `Stat` or a `Geom` extension.
The decision is not guided by whether you want to end out with a `geom_spring()` constructor as plenty of `Stat` extensions are used along with a dedicated `geom_*()` constructor.
Instead you should consider what you are actually doing.
Are we drawing using some pre-existing primitive but interpreting input data in a new way?
Yes!
We are drawing with a path but simply circling around instead of going straight.
This is a clear case for a `Stat` which is great for transforming input data into something that can be drawn with a pre-existing geom.
Further, `Stat`s are much easier to extend than `Geom`s as they are simply data-transformation pipelines.
Thus, in the following we will work towards creating a new `Stat` for drawing springs.

### Building functionality

When developing a new `Stat` it often helps immensely to create the data transformation function separately.
It allows you to only focus on the aspects of ggproto when you really need to, thus freeing some mental space for actual problem solving.
Our data transformation should take a start and end point, a diameter, and a tension.
We will define tension to mean "times of diameter moved per revolution minus one", thus `0` will mean that it doesn't move at all, and will be forbidden as it would not allow our spring to extend between two points.
Further, we will add a parameter `n` giving the number of points to use per revolution, thus defining the visual fidelity of the spring.

```{r}
create_spring <- function(x, y, xend, yend, diameter, tension, n) {
  if (tension <= 0) {
    rlang::abort("`tension` must be larger than 0")
  }
  # Calculate direct length of segment
  length <- sqrt((x - xend)^2 + (y - yend)^2)
  
  # Figure out how many revolutions and points we need
  n_revolutions <- length / (diameter * tension)
  n_points <- n * n_revolutions
  
  # Calculate sequence of radians and x and y offset
  radians <- seq(0, n_revolutions * 2 * pi, length.out = n_points)
  x <- seq(x, xend, length.out = n_points)
  y <- seq(y, yend, length.out = n_points)
  
  # Create the new data
  data.frame(
    x = cos(radians) * diameter/2 + x,
    y = sin(radians) * diameter/2 + y
  )
}
```

One nice thing about encapsulating the functionality in a separate function is that we can immediately test it out and convince our self that the logic works:

```{r}
spring <- create_spring(
  x = 4, y = 2, xend = 10, yend = 6,
  diameter = 2, tension = 0.75, n = 50
)

ggplot(spring) + 
  geom_path(aes(x = x, y = y))
```

With the confidence we get from this, we are ready to encapsulate it all in a new `Stat`.
We'll create the `Stat` in one go, as this is how it is always defined, and then go over the single parts afterwards:

```{r}
StatSpring <- ggproto("StatSpring", Stat, 
  setup_params = function(data, params) {
    if (is.null(params$diameter)) {
      params$diameter <- 1
    } else if (params$diameter == 0) {
      rlang::abort("Springs cannot be defined with a diameter of 0")
    }
    if (is.null(params$tension)) {
      params$tension <- 0.75
    } else if (params$tension <= 0) {
      rlang::abort("Springs must be defined with a tension greater than 0")
    }
    if (is.null(params$n)) {
      params$n <- 50
    } else if (params$n <= 0) {
      rlang::abort("Springs must be defined with `n` greater than 0")
    }
    params
  },
  setup_data = function(data, params) {
    if (anyDuplicated(data$group)) {
      data$group <- paste(data$group, seq_len(nrow(data)), sep = "-")
    }
    data
  },
  compute_panel = function(data, scales, diameter = 1, tension = 0.75, 
                           n = 50) {
    cols_to_keep <- setdiff(names(data), c("x", "y", "xend", "yend"))
    springs <- lapply(seq_len(nrow(data)), function(i) {
      spring_path <- create_spring(data$x[i], data$y[i], data$xend[i], 
                                   data$yend[i], diameter, tension, n)
      cbind(spring_path, unclass(data[i, cols_to_keep]))
    })
    do.call(rbind, springs)
  },
  required_aes = c("x", "y", "xend", "yend")
)
```

Let's take the above code piece by piece: We first start with the class definition

```{r, eval=FALSE}
StatSpring <- ggproto("StatSpring", Stat, 
  ...
}
```

This creates a new `Stat` subclass, named *StatSpring*.
ggproto classes always uses CamelCase for naming, and the new class is always saved into a variable of the same name.
If you are creating a special version of an existing `Stat` it is fully allowed to subclass that instead of the `Stat` base class, but this is more often found in `Geom`, `Coord`, and `Facet` subclasses.

Inside the class definition we provide a range of methods, simply by assigning functions to the argument names of interest.
While it is allowed to dream up new methods, it is most common to simply put all functionality inside the definition of already existing methods.
The `Stat` base class has a range of methods open for overwriting, and some you should steer clear off:

```{r}
print(Stat)
```

The `aesthetics` and `parameters` methods are not meant for overwriting, but the other methods are all open during subclassing.
As discussed in the previous chapters, the most important part is the three `compute_*` methods.
One of these must always be defined (and usually the `group` or `panel` version).
Two other very common methods to overwrite is the `setup_*` methods, which allows the class to do early checks and modifications of the parameters and data of the stat.

In our implementation we provide a `setup_params()` method with the purpose of making sure that all the required parameters are present and that they have supported values assigned.
This is not strictly necessary as the default values in our `compute_*()` method will make sure that lack of defined parameters doesn't cause problems.
Still, it is nice to be explicit, especially with checking the values of the parameters as it is possible to create much more meaningful error messages at this point.

We also implement a `setup_data()` method.
We do this to make sure that each row in the input data has a unique group aesthetic assigned.
ggplot2 will always create a group aesthetic for us if none is present, but it will depend on the values and types of the other aesthetics.
Since our stat will expand each row into multiple rows that should be drawn as separate paths, we need each row to have a unique group.
Instead of simply assigning a new unique number to the group column, we paste it together with the old value.
This is good practice as the group aesthetic is sometimes used to carry information.

For the actual computation we choose to define the `compute_panel()` method.
This method will receive the data for each panel (plotting area) and do the transformation on that.
Our stat handles each row individually, so if we instead implemented a `compute_group()` method our data would be split up into individual rows, a rather costly operation with very little benefit for us.
As a general rule of thumb, if the stat operates on multiple rows, start by implementing a `compute_group()` method, and if the stat operates on single rows, implement a `compute_panel()` method.

Inside our `compute_panel()` method we do a bit more than simply call our `create_spring()` function.

```{r}
StatSpring$compute_panel
```

We loop over each row of the data and create the points required to draw the spring.
Then we combine our new data with all the non-position columns of the row.
This is very important, since otherwise the aesthetic mappings to e.g. color and size would be lost.
In the end we combine the individual springs into a single data frame that gets returned.

The last remaining part of our new class is the `required_aes` field.
This is simply a character vector giving the names of aesthetics that the user *must* provide for the stat.
The `required_aes`, along with `default_aes` and `non_missing_aes` also defines the aesthetics that this stat understands.
Along with the counterpart in a geom, these aesthetics are the ones that a layer can work with and any mapping to aesthetics not mentioned will cause a warning and the mapping will be removed.

### Constructors

Users never really see the ggproto objects (unless they go looking for them), since they are abstracted away into the well-known constructor functions that make up the ggplot2 API.
Having created our stat, we should probably also create a constructor.

> It should be noted that a constructor is not strictly needed.
> We currently have everything needed to call `geom_path(stat = "spring")`, but if we don't provide a constructor there will be no place to document our new functionality.

While this is a stat, we will first and foremost create a `geom_*()` constructor.
This is because most people are accustomed to adding geoms as opposed to stats when building up their plot.
The constructor is mainly boilerplate code.
Care should be taken to match the argument order and naming used in the geom constructors provided by ggplot2 itself since users have an internalized expectation about how they work.

```{r}
geom_spring <- function(mapping = NULL, data = NULL, stat = "spring", 
                        position = "identity", ..., diameter = 1, tension = 0.75, 
                        n = 50, arrow = NULL, lineend = "butt", linejoin = "round", 
                        na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) {
  layer(
    data = data, 
    mapping = mapping, 
    stat = stat, 
    geom = GeomPath, 
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes, 
    params = list(
      diameter = diameter, 
      tension = tension, 
      n = n, 
      arrow = arrow, 
      lineend = lineend, 
      linejoin = linejoin, 
      na.rm = na.rm, 
      ...
    )
  )
}
```

As can be seen, the constructor is a simple wrapper around `layer()` setting sensible defaults and funneling layer parameters into the correct location.

Having everything in place, we can now test out our new layer for the first time.

```{r}
some_data <- tibble(
  x = runif(5, max = 10),
  y = runif(5, max = 10),
  xend = runif(5, max = 10),
  yend = runif(5, max = 10),
  class = sample(letters[1:2], 5, replace = TRUE)
)

ggplot(some_data) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend))
```

Having implemented our layer, we can now benefit from all the automatic features normally associated with ggplot2, such as scaling and faceting:

```{r}
ggplot(some_data) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend, colour = class)) + 
  facet_wrap(~ class)
```

For completion we will also create a stat constructor.
The `stat_spring()` function looks almost identical except that it does not force a geom but a stat instead.
Further we will usually not provide default argument for the default geom:

```{r}
stat_spring <- function(mapping = NULL, data = NULL, geom = "path", 
                        position = "identity", ..., diameter = 1, tension = 0.75, 
                        n = 50, na.rm = FALSE, show.legend = NA, 
                        inherit.aes = TRUE) {
  layer(
    data = data, 
    mapping = mapping, 
    stat = StatSpring, 
    geom = geom, 
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes, 
    params = list(
      diameter = diameter, 
      tension = tension, 
      n = n, 
      na.rm = na.rm, 
      ...
    )
  )
}
```

We will test this by drawing our springs with dots instead:

```{r}
ggplot(some_data) + 
  stat_spring(aes(x = x, y = y, xend = xend, yend = yend, colour = class),
              geom = 'point', n = 15) + 
  facet_wrap(~ class)
```

### Post-Mortem

We have now successfully created our first extension.
The first implementation is almost never the end of it, though, as new insight appears during development and make you rethink your approaches.
One shortcoming of our implementation is that diameter and tension can only be set for the full layer.
These settings feel more like aesthetics and it would be nice if their values could be mapped to a variable in the data.
We will revisit this point in the next chapter, were we rewrite our `Stat` to support this.

Another, potentially bigger, issue is that the spring path is relative to the coordinate system of the plot.
This means that strong deviations from an aspect ratio of 1 will visibly distort the spring, as can be seen in the example below:

```{r}
ggplot() + 
  geom_spring(aes(x = 0, y = 0, xend = 3, yend = 20))
```

The same underlying problem means that the diameter is expressed in coordinate space, meaning that it is difficult to define a meaningful default:

```{r}
ggplot() + 
  geom_spring(aes(x = 0, y = 0, xend = 100, yend = 80))
```

This is one of the biggest downsides (or features, depending on your need) of shapes and line geoms defined as stats expansions.
We'll fix this next, by creating a new geom from the ground up.

## Part 2: Adding aesthetics {#spring2}

In the last we created a first version of our spring stat, complete with constructors and what-not.
Now, we'll turn the `diameter` and `tension` arguments into aesthetics instead, that can be set on a per-spring level.

### Moving to aesthetics

There is surprisingly little to do in order to make `diameter` and `tension` behave like aesthetics.
One downside (which we will tackle later) is that stats cannot set aesthetics as parameters.
This means that with the implementation below, it will no longer be possible to set `diameter` and `tension` outside of `aes()`.

```{r}
StatSpring <- ggproto("StatSpring", Stat, 
  setup_params = function(data, params) {
    if (is.null(params$n)) {
      params$n <- 50
    } else if (params$n <= 0) {
      rlang::abort("Springs must be defined with `n` greater than 0")
    }
    params
  },
  setup_data = function(data, params) {
    if (anyDuplicated(data$group)) {
      data$group <- paste(data$group, seq_len(nrow(data)), sep = "-")
    }
    if (is.null(data$diameter)) {
      data$diameter <- 1
    }
    if (any(data$diameter == 0)) {
      rlang::abort("Springs cannot be defined with a diameter of 0")
    }
    if (is.null(data$tension)) {
      data$tension <- 0.75
    }
    if (any(data$tension <= 0)) {
      rlang::abort("Springs must be defined with a tension greater than 0")
    }
    data
  },
  compute_panel = function(data, scales, n = 50) {
    cols_to_keep <- setdiff(names(data), c("x", "y", "xend", "yend"))
    springs <- lapply(seq_len(nrow(data)), function(i) {
      spring_path <- create_spring(data$x[i], data$y[i], data$xend[i], 
                                   data$yend[i], data$diameter[i],
                                   data$tension[i], n)
      cbind(spring_path, unclass(data[i, cols_to_keep]))
    })
    do.call(rbind, springs)
  },
  required_aes = c("x", "y", "xend", "yend"),
  optional_aes = c("diameter", "tension")
)
```

This looks very much like the Stat we created previously, with a few things moved around.
We have removed the check and default settings of `diameter` and `tension` from `setup_params()`, and instead checks the respective columns in `setup_data()`.
We have also removed the arguments in `compute_panel()` as the values are now passed in with the data.
Within `compute_panel()` we also grabs `diameter` and `tension` from the data instead, just like we do for `x`, `y`, etc.

The constructor also need a slight modification to remove the new aesthetics from the parameter list:

```{r}
geom_spring <- function(mapping = NULL, data = NULL, stat = "spring", 
                        position = "identity", ..., n = 50, arrow = NULL, 
                        lineend = "butt", linejoin = "round", na.rm = FALSE,
                        show.legend = NA, inherit.aes = TRUE) {
  layer(
    data = data, 
    mapping = mapping, 
    stat = stat, 
    geom = GeomPath, 
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes, 
    params = list(
      n = n, 
      arrow = arrow, 
      lineend = lineend, 
      linejoin = linejoin, 
      na.rm = na.rm, 
      ...
    )
  )
}
```

The `stat_spring()` constructor would require the same kind of change, but we'll let that be for now.

All that is left is to test our new implementation out:

```{r}
some_data <- tibble(
  x = runif(5, max = 10),
  y = runif(5, max = 10),
  xend = runif(5, max = 10),
  yend = runif(5, max = 10),
  class = sample(letters[1:2], 5, replace = TRUE),
  tension = runif(5),
  diameter = runif(5, 0.5, 1.5)
)

ggplot(some_data) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend, tension = tension, 
                  diameter = diameter))
```

It appears to work, but as can be seen we can no longer set `diameter` and `tension` as paramaters (outside of `aes()`)

```{r}
ggplot(some_data) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend, tension = tension),
              diameter = 0.5)
```

### Post-Mortem

In this section we further developed our spring stat so that the two defining features (`diameter` and `tension`) can be used as aesthetics and thus vary between the different springs in a visualization.
Our implementation has the downside that these features no longer can be set globally; this possibility is reserved for geoms for now.
We are still missing a way to control the scaling of the two aesthetics so the mapped values are taken as-is.
Such scaling is not possible with our current approach since scaling happens after the stats calculation at which point the path of our springs have been fixed.
Our next step is thus to move our implementation away from `Stat` and into a proper `Geom`.

## Part 3: A geom {#spring3}

In the last section we came as far as possible with our `Stat`-centered approach to a spring geom.
In some cases this is enough.
Many of the graphic primitives provided by the ggforce extension package is developed in this manner.
Aspects of our spring geom means that we need to go further here (also, this is to learn about extensions so it would be bad pedagogy to stop now).
These aspects, specifically, is that there is visual appearances of the spring that need to be unrelated to the coordinate system (the `tension` and `diameter` aesthetics).
Consequently, we'll rewrite our geom to be a proper `Geom` extension.

### Geom extensions

As discussed in the [overview of extensions](#extensions), there are many similarities between `Stat` and `Geom` extensions.
The biggest difference is that `Stat` extensions returns a modified version of the input data, whereas `Geom` extensions return grid grobs (more on that later).
Since our geom is basically a path, we can get pretty far by simply extending `GeomPath` by changing the data before it is rendered:

```{r, eval=FALSE}
GeomSpring <- ggproto("GeomSpring", GeomPath,
  ...,
  setup_data = function(data, params) {
    cols_to_keep <- setdiff(names(data), c("x", "y", "xend", "yend"))
    springs <- lapply(seq_len(nrow(data)), function(i) {
      spring_path <- create_spring(data$x[i], data$y[i], data$xend[i], 
                                   data$yend[i], data$diameter[i],
                                   data$tension[i], params$n)
      spring_path <- cbind(spring_path, unclass(data[i, cols_to_keep]))
      spring_path$group <- i
      spring_path
    })
    do.call(rbind, springs)
  },
  ...
)
```

In the above we have used the `setup_data()` method to avoid having to think about rendering at all.
Since our `create_spring()` function returns data that `GeomPath` inherently understand we can simply piggy-back on its `draw_*()` methods.
Now, this is an imperfect solution and not really an improvement over our `StatSpring` approach.
`setup_data()` is called before default aesthetics and set aesthetics are added to the data, so it will only work if everything is defined within `aes()`.
While `setup_data()` is very nice for some situations you should always be very aware of the limitation it has in terms of what data is available to it.

To improve upon this we will need to move our generation into the `draw_*()` methods.
However, we can still utilize the `GeomPath` implementation to avoid having to deal with grid grob generation just yet:

```{r}
GeomSpring <- ggproto("GeomSpring", Geom,
  setup_params = function(data, params) {
    if (is.null(params$n)) {
      params$n <- 50
    } else if (params$n <= 0) {
      rlang::abort("Springs must be defined with `n` greater than 0")
    }
    params
  },
  setup_data = function(data, params) {
    if (is.null(data$group)) {
      data$group <- seq_len(nrow(data))
    }
    if (anyDuplicated(data$group)) {
      data$group <- paste(data$group, seq_len(nrow(data)), sep = "-")
    }
    data
  },
  draw_panel = function(data, panel_params, coord, n = 50, arrow = NULL,
                        lineend = "butt", linejoin = "round", linemitre = 10,
                        na.rm = FALSE) {
    cols_to_keep <- setdiff(names(data), c("x", "y", "xend", "yend"))
    springs <- lapply(seq_len(nrow(data)), function(i) {
      spring_path <- create_spring(data$x[i], data$y[i], data$xend[i], 
                                   data$yend[i], data$diameter[i],
                                   data$tension[i], n)
      cbind(spring_path, unclass(data[i, cols_to_keep]))
    })
    springs <- do.call(rbind, springs)
    GeomPath$draw_panel(
      data = springs, 
      panel_params = panel_params, 
      coord = coord, 
      arrow = arrow, 
      lineend = lineend, 
      linejoin = linejoin, 
      linemitre = linemitre, 
      na.rm = na.rm
    )
  },
  required_aes = c("x", "y", "xend", "yend"),
  default_aes = aes(
    colour = "black", 
    size = 0.5, 
    linetype = 1L, 
    alpha = NA, 
    diameter = 1, 
    tension = 0.75
  )
)
```

Developers used to object-oriented design may frown upon this design where we call the method of another kindred object directly (`GeomPath$draw_panel()`), but since `Geom` objects are stateless this is as safe as subclassing `GeomPath` and calling the parent method.
You can see this approach all over the place in the ggplot2 source code.
If you compare this code to our `StatSpring` implementation in the last chapter you can see that the `compute_panel()` and `draw_panel()` methods are quite similar with the main difference being that we pass on the computed spring coordinates to `GeomPath$draw_panel()` in the latter method.
Our `setup_data()` method has been greatly simplified because we now relies on the `default_aes` functionality in `Geom` to fill out non-mapped aesthetics.

Creating the `geom_spring()` constructor is almost similar, except that we now uses the identity stat instead of our spring stat and uses the new `GeomSpring` instead of `GeomPath`.

```{r}
geom_spring <- function(mapping = NULL, data = NULL, stat = "identity", 
                        position = "identity", ..., n = 50, arrow = NULL, 
                        lineend = "butt", linejoin = "round", na.rm = FALSE,
                        show.legend = NA, inherit.aes = TRUE) {
  layer(
    data = data, 
    mapping = mapping, 
    stat = stat, 
    geom = GeomSpring, 
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes, 
    params = list(
      n = n, 
      arrow = arrow, 
      lineend = lineend, 
      linejoin = linejoin, 
      na.rm = na.rm, 
      ...
    )
  )
}
```

Without much additional work we now have a proper geom with working default aesthetics and the possibility of setting aesthetics as parameters.

```{r}
ggplot(some_data) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend),
              diameter = 0.5)
```

This is basically how far we can get without moving in to grid territory.
Creating grid grobs is somewhat of an advanced subject so we will give it its own chapter.
Using the techniques described in the last three chapters is enough to solve 95% of your geom extension needs and creating new grobs is almost never required except for when you need to transform your data relative to the physical size of the plot (e.g. setting the diameter of our spring to 1 cm).

### Post-Mortem

In this section we finally created a proper `Geom` extension that behaves as we would expect.
You may think that this is always the natural conclusion to the development of new layer types, but there is also value in the `Stat` approach, mainly that it makes it possible to use the data transformation with multiple different geoms (e.g. plotting dots at each coordinate instead of connecting them to a path).
The final choice is ultimately up to you and should be guided by how you envision the layer to be used.

We have not yet talked about what goes on inside the `draw_*()` methods.
Often it is enough to use a method from another geom and don't worry about it.
Even for something quite complex like the boxplot geom you will see that it simply combines output from multiple different geoms such as `GeomSegment` and `GeomCrossbar`.
We will get much deeper into the `draw_*()` methods in the next section when we also create our own grob.

## Part 4: A grid grob {#spring4}

In the last section we exhausted our options for our spring geom safe for delving into the development of a new grid grob.
grid is the underlying graphic system that ggplot2 builds upon and while much can be achieved by ignoring grid entirely, there are situations where it is impossible to achieve what you want without going down to the grid level.
There are especially two situations that warrant the need for using grid directly when developing ggplot2 extensions:

1.  You need to create graphical objects that are positioned correctly on the coordinate system, but where some part of their appearance has a fixed absolute size.
    In our case this would be the spring correctly going between two points in the plot, but the diameter being defined in cm instead of relative to the coordinate system.

2.  You need graphical objects that are updated during resizing.
    This could e.g. be the position of labels such as in the ggrepel package or the `geom_mark_*()` geoms in ggforce.

Before we begin developing the new version of our geom it will be good to have at least a cursory understanding of the key concepts in grid:

### Grid in 5 minutes

grid is one of two graphic systems distributed with R (the other being base graphics).
It works quite differently from base graphics in that graphics is build up by creating a nested description of the graphic, rather than directly sending drawing instructions to the device.
The benefit of this is that the description of the graphic exists outside of the graphic device as an R object that can be passed around, modified, etc. and that parts of the graphical description can reference other parts (e.g., *make this rectangle as wide as this string of text*).
Once the description is plotted grid will react to resizing of the graphic device and rerender the current plot.
This means that grid graphic is able to be dimension aware and is the reason why it is possible to resize a ggplot2 plot and keep the margins fixed while the plotting region expands.

While a thorough review of how grid works is beyond the scope of this chapter, there is a couple of concepts and classes that is required to understand for ggplot2 extension developers:

#### Grobs

Grobs (***gr***aphic ***ob***jects) are the atomic representations of graphical elements in grid.
As such they can be likened to the different elements that exists in the SVG definition such as `<circle/>` and `<text/>`.
In contrast to SVG, grobs are vectorised so that e.g. a point grob can represent multiple points.
Grid comes with a range of build-in grobs that cover the vast majority of use cases as well as the means to combine multiple grobs into a `gTree()` which groups them together into what is conceptually a single grob.

It is possible to create new grob classes with the `grob()` or `gTree()` constructors.
By defining `makeContext()` and `makeContent()` methods for your class you can control how it behaves during rendering.
`makeContext()` is called when the parent grob is rendered and allows you to control the viewport of the grob (see below).
`makeContent()` is called everytime the drawing region is resized and allows you to customise the look based on the size or other aspect.

#### Viewports

Viewports are plotting region definitions.
They have their own coordinate system that grobs in the viewport will be positioned according to.
They may also define a tabular grid that child viewports can occupy.
A grob can have it's own viewport or inherit the viewport of it's parent.
While we will not need to modify the viewport of our spring grob (once developed), viewports is an important concept that opens the door for many possibilities.

#### Units

grid has a very flexible way of specifying positions and dimensions of grobs and viewports.
All of this is encapsulated in the `unit()` class which support both absolute units (e.g. centimeters, inches, and points), relative units (e.g. npc which scales the viewport size between 0 and 1), and units based on other grobs (e.g. grobwidth).
units support arithmetic operations and are only resolved at draw time (where all units are absolute) so it is possible to combine all types of units, e.g. `unit(0.5, 'npc') + unit(1, 'cm')` defines a point one centimeter to the left of the center of the current viewport.

#### Example

With our very cursory introduction, let us now see an example grob implementation.
The code below will create a grob that appears as a square if the size of it is above 5 cm and a circle if it is below:

```{r}
library(grid)
surpriseGrob <- function(x, y, size, default.units = "npc", name = NULL, 
                         gp = gpar(), vp = NULL) {
  # Check if input needs to be converted to units
  if (!is.unit(x)) {
    x <- unit(x, default.units)
  }
  if (!is.unit(y)) {
    y <- unit(y, default.units)
  }
  if (!is.unit(size)) {
    size <- unit(size, default.units)
  }
  # Construct our surprise grob subclass as a gTree
  gTree(x = x, y = y, size = size, name = name, gp = gp, vp = vp, cl = "surprise")   
}
makeContent.surprise <- function(x) {
  x_pos <- x$x
  y_pos <- x$y
  size <- convertWidth(x$size, unitTo = "cm", valueOnly = TRUE)
  
  # Figure out if the given sizes are bigger or smaller than 5 cm
  circles <- size < 5
  
  # Create a circle grob for the small ones
  if (any(circles)) {
    circle_grob <- circleGrob(
      x = x_pos[circles], 
      y = y_pos[circles], 
      r = unit(size[circles] / 2, "cm")
    )
  } else {
    circle_grob <- nullGrob()
  }
  
  
  # Create a rect grob for the large ones
  if (any(!circles)) {
    square_grob <- rectGrob(
      x = x_pos[!circles], 
      y = y_pos[!circles], 
      width = unit(size[!circles], "cm"),
      height = unit(size[!circles], "cm")
    )
  } else {
    square_grob <- nullGrob()
  }
  
  
  # Add the circle and rect grob as childrens of our input grob
  setChildren(x, gList(circle_grob, square_grob))
}

# Create an instance of our surprise grob defining to object with different
# sizes
gr <- surpriseGrob(x = c(0.25, 0.75), y = c(0.5, 0.5), size = c(0.1, 0.4))

# Draw it
grid.newpage()
grid.draw(gr)
```

If you run the code above interactively and resize the plotting window you can see that the two objects will change form based on the size of the plotting window.
This is a useless example, of course, but hopefully you can see how this technique can be used to do real work.

### The springGrob

With our new knowledge of the grid system we can now see how we might construct a spring grob that have an absolute diameter.
If we wait with the expansion to the spring path until the `makeContent()` function, and calculate it based on coordinates in absolute units we can make sure that the diameter stays constant during resizing of the plot.
With that in mind, we can create our constructor.
We model the arguments after `segmentsGrob()` since we are basically creating modified segments:

```{r}
springGrob <- function(x0 = unit(0, "npc"), y0 = unit(0, "npc"), 
                       x1 = unit(1, "npc"), y1 = unit(1, "npc"), 
                       diameter = unit(0.1, "npc"), tension = 0.75,
                       n = 50, default.units = "npc", name = NULL, 
                       gp = gpar(), vp = NULL) {
  if (!is.unit(x0)) x0 <- unit(x0, default.units)
  if (!is.unit(x1)) x1 <- unit(x1, default.units)
  if (!is.unit(y0)) y0 <- unit(y0, default.units)
  if (!is.unit(y1)) y1 <- unit(y1, default.units)
  if (!is.unit(diameter)) diameter <- unit(diameter, default.units)
  gTree(x0 = x0, y0 = y0, x1 = x1, y1 = y1, diameter = diameter, 
       tension = tension, n = n, name = name, gp = gp, vp = vp, 
       cl = "spring")
}
```

We see that once again our constructor is a very thin wrapper around the `gTree()` constructor, simply ensuring that arguments are converted to units if they are not already.

We now need to create the `makeContent()` method that creates the actual spring coordinates.

```{r}
makeContent.spring <- function(x) {
  x0 <- convertX(x$x0, "mm", valueOnly = TRUE)
  x1 <- convertX(x$x1, "mm", valueOnly = TRUE)
  y0 <- convertY(x$y0, "mm", valueOnly = TRUE)
  y1 <- convertY(x$y1, "mm", valueOnly = TRUE)
  diameter <- convertWidth(x$diameter, "mm", valueOnly = TRUE)
  tension <- x$tension
  n <- x$n
  springs <- lapply(seq_along(x0), function(i) {
    cbind(
      create_spring(x0[i], y0[i], x1[i], y1[i], diameter[i], tension[i], n),
      id = i
    )
  })
  springs <- do.call(rbind, springs)
  spring_paths <- polylineGrob(springs$x, springs$y, springs$id, 
                               default.units = "mm", gp = x$gp)
  setChildren(x, gList(spring_paths))
}
```

There is not anything fancy going on here.
We grabs the coordinates and diameter settings from the gTree and converts them all to millimeters.
As we now have everything in absolute units we calculate the spring paths using our trusted `create_spring()` function and puts the returned coordinates in a polyline grob.

Before we use this in a geom let us test it out:

```{r}
springs <- springGrob(
  x0 = c(0, 0),
  y0 = c(0, 0.5),
  x1 = c(1, 1),
  y1 = c(1, 0.5),
  diameter = unit(c(1, 3), "cm"),
  tension = c(0.2, 0.7)
)
grid.newpage()
grid.draw(springs)
```

It appears to work and we can now design our new (and final) geom.

### The last GeomSpring

```{r}
GeomSpring <- ggproto("GeomSpring", Geom,
  setup_params = function(data, params) {
    if (is.null(params$n)) {
      params$n <- 50
    } else if (params$n <= 0) {
      rlang::abort("Springs must be defined with `n` greater than 0")
    }
    params
  },
  draw_panel = function(data, panel_params, coord, n = 50, lineend = "butt", 
                        na.rm = FALSE) {
    data <- remove_missing(data, na.rm = na.rm,
      c("x", "y", "xend", "yend", "linetype", "size"),
      name = "geom_spring")
    if (is.null(data) || nrow(data) == 0) return(zeroGrob())
    if (!coord$is_linear()) {
      rlang::warn("spring geom only works correctly on linear coordinate systems")
    }
    coord <- coord$transform(data, panel_params)
    return(springGrob(coord$x, coord$y, coord$xend, coord$yend,
      default.units = "native", diameter = unit(coord$diameter, "cm"),
      tension = coord$tension, n = n,
      gp = gpar(
        col = alpha(coord$colour, coord$alpha),
        lwd = coord$size * .pt,
        lty = coord$linetype,
        lineend = lineend
      )
    ))
  },
  required_aes = c("x", "y", "xend", "yend"),
  default_aes = aes(
    colour = "black", 
    size = 0.5, 
    linetype = 1L, 
    alpha = NA, 
    diameter = 0.35, 
    tension = 0.75
  )
)
geom_spring <- function(mapping = NULL, data = NULL, stat = "identity", 
                        position = "identity", ..., n = 50, lineend = "butt", 
                        na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) {
  layer(
    data = data, 
    mapping = mapping, 
    stat = stat, 
    geom = GeomSpring, 
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes, 
    params = list(
      n = n, 
      lineend = lineend, 
      na.rm = na.rm, 
      ...
    )
  )
}
```

The main differences from our last `GeomSpring` implementation is that we no longer care about a `group` column because each spring is defined in one line, and then of course the `draw_panel()` method.
Since we are no longer passing on the call to another geoms `draw_panel()` method we have additional obligations in that call.
If the coordinate system is no linear (e.g. `coord_polar()`) we emit a warning because our spring will not be adapted to that coordinate system.
We then use the coordinate system to rescale our positional aesthetics with the `transform()` method.
This will remap all positional aesthetics to lie between 0 and 1, with 0 being the lowest value visible in our viewport (scale expansions included) and 1 being the highest.
With this remapping the coordinates are ready to be passed into a grob as `"npc"` units.
By definition we understands the provided diameter as been given in centimeters.
With all the values properly converted we call the `springGrob()` constructor and return the resulting grob.
One thing we haven't touched upon is the `gpar()` call inside the `springGrob()` construction.
grid operates with a short list of very well-defined visual characteristics for grobs that are given by the `gp` argument in the constructor.
This takes a `gpar` object that holds information such as colour of the stroke and fill, linetype, font, size, etc.
Not all grobs care about all entries in `gpar()` and since we are constructing a line we only care about the gpar entries that the pathGrob understands, namely: `col` (stroke colour), `lwd` (line width), `lty` (line type), `lineend` (the terminator shape of the line).

```{r}
ggplot(some_data) + 
  geom_spring(aes(
    x = x, 
    y = y, 
    xend = xend, 
    yend = yend, 
    diameter = diameter, 
    tension = tension
  ))
```

As can be seen in the example above we now have springs that do not shear with the aspect ratio of the plot and thus looks conform at every angle and aspect ratio.
Further, resizing the plot will result in recalculations of the correct path so that it will continues to look as it should.

### Post-Mortem

We have finally arrived at the spring geom we set out to make.
The diameter of the spring behaves in the same way as a line width in that it remains fixed when resizing and/or changing the aspect ratio of the plot.
There are still improvements we could (and perhaps, should) do to our geom.
Most notably our `create_spring()` function remains un-vectorised and needs to be called for each spring separately.
Correctly vectorizing this function will allow for considerable speed-up when rendering many springs (if that was ever a need).
We will leave this as an exercise for the reader.

While the geom is now done, we still a have a little work to do.
We need to create a diameter scale and provide legend keys that can correctly communicate diameter and tension.
This will be the topic of the final section.

## Part 5: Scales {#spring5}

Now that we have our final geom, there's still a bit of work to do before we are done.
This is because we have defined a couple of new aesthetics in the process and we would like users to be able to scale them.
There's nothing wrong with defining new aesthetics without providing a scale --- that simply means that the mapped values are passed through unchanged --- but if we want users to have some control as well as the possibility of a legend we will need to provide scales for the aesthetics.
This will be the goal of this final section.

### Scaling

Thankfully, compared to grid, creating new scales is not a huge undertaking.
It basically surmounts to creating a function with the correct name that outputs a `Scale` object.
In the code below you can see how this is done for the `tension` aesthetic:

```{r}
scale_tension_continuous <- function(..., range = c(0.1, 1)) {
  continuous_scale(
    aesthetics = "tension", 
    scale_name = "tension_c", 
    palette = scales::rescale_pal(range), 
    ...
  )
}
```

Most scale functions are simply wrappers around calls to one of the scale constructors (`continuous_scale()`, `discrete_scale()`, and `binned_scale()`).
Most importantly it names the aesthetic(s) this scale relates to and provides a palette function which transforms the input domain to the output range.
All the remaining well-known arguments from scale functions such as `name`, `breaks`, `limits`, etc. are carried through with the `...`.
For cases such as these where only a single scale is relevant for an aesthetic you'll often create a short-named version as well.
We'll also add a discrete scale to catch if this aesthetic is erroneously being used with discrete data:

```{r}
scale_tension <- scale_tension_continuous

scale_tension_discrete <- function(...) {
  rlang::abort("Tension cannot be used with discrete data")
}
```

The reason why we need `scale_tension_continuous()` when we also have `scale_tension()` is that the default scale for aesthetics is looked up by searching for a function called `scale_<aesthetic-name>_<data-type>`.

While we are at it we'll create a scale for the diameter as well:

```{r}
scale_diameter_continuous <- function(..., range = c(0.25, 0.7), unit = "cm") {
  range <- grid::convertWidth(unit(range, unit), "cm", valueOnly = TRUE)
  continuous_scale(
    aesthetics = "diameter", 
    scale_name = "diameter_c", 
    palette = scales::rescale_pal(range), 
    ...
  )
}
scale_diameter <- scale_diameter_continuous
scale_tension_discrete <- function(...) {
  rlang::abort("Diameter cannot be used with discrete data")
}
```

The only change we made from the `tension` scales is that we allow the user to define which unit the diameter range should be measured in.
Since the geom expects centimeters we will convert the range to that before passing it into the scale constructor.
In that way the user is free to use whatever absolute unit feels natural to them.

With our scales defined let us have a look:

```{r}
ggplot(some_data) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend, tension = tension, 
                  diameter = diameter)) + 
  scale_tension(range = c(0.1, 5))
```

The code above shows us that both the default scale (we didn't add an explicit scale for diameter) and the custom scales (`scale_tension()`) work.
It also tells us that our job is not done, because the legend is pretty uninformative.
That is because our geom uses the default legend key constructor which is `draw_key_point()`.
This key constructor doesn't know what to do about our new aesthetics and ignores it completely.

### draw_key_spring

The key constructors are pretty simple constructors that take a data.frame of aesthetic values and uses that to draw a given representation.
If we look at the point key constructor we see that it simply constructs a pointsGrob:

```{r}
draw_key_point
```

`data` is a data.frame with a single row giving the aesthetic values to use for the key, `params` are the geom params for the layer, and `size` is the size of the key area in centimeters.

To create one that matches well with our new geom we should simply try to create a key that uses our springGrob instead:

```{r}
`%||%` <- function(x, y) {
  if (is.null(x)) y else x
}

draw_key_spring <- function(data, params, size) {
  springGrob(
    x0 = 0, y0 = 0, x1 = 1, y1 = 1,
    diameter = unit(data$diameter, "cm"), 
    tension = data$tension,
    gp = gpar(
      col = alpha(data$colour %||% "black", data$alpha),
      lwd = (data$size %||% 0.5) * .pt,
      lty = data$linetype %||% 1
    ),
    vp = viewport(clip = "on")
  )
}
```

We add a little flourish here that is not necessary for the point key constructor, which is that we define a clipping viewport for our grob.
This means that the spring will not spill-out into the neighboring keys.

Along with that we will also have to modify our Geom to use this key constructor instead (I know I said the last version was final).
We don't have to define our Geom from scratch again, though but simply change the `draw_key()` method of our existing Geom:

```{r}
GeomSpring$draw_key <- draw_key_spring
```

With that final change our legend is beginning to make sense:

```{r}
ggplot(some_data) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend, tension = tension, 
                  diameter = diameter)) + 
  scale_tension(range = c(0.1, 5))
```

The default key size is a bit cramped for our key, but that has to be modified by the user (ggplot2 doesn't know about the `diameter` aesthetic and cannot scale the key size to that in the same way as it does with the `size` aesthetic).

```{r}
ggplot(some_data) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend, tension = tension, 
                  diameter = diameter)) + 
  scale_tension(range = c(0.1, 5)) + 
  theme(legend.key.size = unit(1, "cm"))
```

The new legend key will be used for all scaled aesthetics, not just our new `diameter` and `tension` meaning that the key will always match the style of the layer:

```{r}
ggplot(some_data) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend, colour = class)) + 
  theme(legend.key.size = unit(1, "cm"))
```

### Post-Mortem

This concludes our, admittedly a bit far-fetched, case study on how to create a spring geom.
Hopefully it has become clear that there are many different ways to achieve the same geom extension and where you end up is largely guided by your needs and how much energy you want to put into it.
While extending layers (and scales) are only a single (but important) part of the ggplot2 extension system, we will not discuss how to create other types of extensions such as coord and facet extensions.
The curious reader is invited to study the source code of both ggplot2's own Facet and Coord classes as well as the extensions available in e.g. the ggforce package.
